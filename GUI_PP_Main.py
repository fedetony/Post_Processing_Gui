# -*- coding: utf-8 -*-
#*********************************
# Author :F. Garcia
# Created 19.08.2022
#*********************************
__author__="FG"
__version__="1.0.0 Beta"
__creationdate__="19.08.2022"
__gitaccount__="<a href=\"https://github.com/fedetony\">' Github for fedetony'</a>"

# Form implementation generated automaticaly from reading ui file 'GUI_PostProcessing.ui'
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to 'GUI_PostProcessing.py' will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from genericpath import isfile
from operator import index
import sys
import os
import logging
import threading
#import glob
#import pkg_resources
import matplotlib.pyplot as plt
import matplotlib.backends.backend_pdf
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import yaml
import pandas as pd
from PyQt5 import QtCore, QtGui, QtWidgets
import queue


import GUI_PostProcessing
import class_File_Dialogs
import class_PlotPreview
import class_TreeViewFunctions
from collections import deque
import datetime
import json
#import re

#Setup Logger
import class_LogHandler
# set up logging to file - see previous section for more details
log = logging.getLogger('') #root logger
#For file
'''
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s [%(levelname)s] (%(threadName)-10s) %(message)s',
                    datefmt='%y-%m-%d %H:%M',
                    filename='/temp/__last_run__.log',
                    filemode='w')
'''
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s [%(levelname)s] (%(threadName)-10s) %(message)s',
                    datefmt='%y-%m-%d %H:%M')
# define a Handler which writes INFO messages or higher to the sys.stderr
#console = logging.StreamHandler()
console = logging.StreamHandler(sys.stdout)
console.setLevel(logging.INFO)
# set a format which is simpler for console use
formatter = logging.Formatter('[%(levelname)s] (%(threadName)-10s) %(message)s')
# tell the handler to use this format
console.setFormatter(formatter)
# add the handler to the root logger
logging.getLogger('').addHandler(console)


class Ui_MainWindow_PP(GUI_PostProcessing.Ui_MainWindow):
    def __init__(self, *args, **kwargs):
        super(Ui_MainWindow_PP, self).__init__(*args, **kwargs) 

    def start_up(self):        
        log.info("UI started!")
        #Initial conditions variables
        self.killer_event = threading.Event()  
        self.Data_avilable=False
        self.app_path=self.get_appPath()   
        self.csv_file_name=''
        self.csv_file_path=''
        self.df={} 
        self.open_Dialogs={}
        self.last_opened={'last_opened_csv':'','last_opened_json':''}
        
        self.General_Config=self.get_general_config()        
        self.prefix=''
        self.des_res_path=''
        self.CopyPaste_plot_dict={'plot_track':[]}
        #self.single_plot=self.get_single_plot_struct()
        one_plot_struct=self.get_one_plot_struct('Unique Name 1')
        two_plot_struct=self.get_one_plot_struct('Unique Name 2')
        self.plots_struct=[one_plot_struct,two_plot_struct]
        self.plots_struct_mask=[self.get_single_plot_struct_mask()]
        self.has_Changed_PlotStructure=False
        
        
    
    
    def open_last_files(self):
        try:
            if self.General_Config['open_last_loaded_files']==True:                
                locsv,lojson=self.get_last_opened_yml_file()       
                log.info('Trying to open last used files:\n{} and \n {} \nChange "open_last_loaded_files" in config file to False to avoid this.'.format(locsv,lojson))         
                if os.path.exists(locsv)==True:
                    self.Open_CSV_File(locsv)
                if os.path.exists(lojson)==True:
                    self.Load_Plot_Struct_json(lojson)

        except Exception as e:
            log.error('Trying to open last files')
            log.error(e)        

    def get_one_axis_struct(self,Axis_Data_Key='',Axis_Data_Range=[-100,100],Axis_Label='',Axis_Scale_Range=[-100,100],Settick=True,RotationTick=0,Stepsizetick=5.0,Fontsizetick=12,autorange=False):
        sps={'Axis_Data_Key':Axis_Data_Key,
             'Axis_Auto_Range': autorange,
             'Axis_Data_Range': Axis_Data_Range,
             'Axis_Label':{'Label_Text':Axis_Label,'Fontsize_Label':12,'Rotation_Label':0},
             'Axis_Auto_Scale': True, 
             'Axis_Scale_Range': Axis_Scale_Range,
             'Axis_Show_Ticks': True,
             'Axis_Ticks':{'Set_Tick':Settick,'Annotation_Data_Key':'','Rotation_Tick':RotationTick,'Step_Size_Tick':Stepsizetick,'Fontsize_Tick':Fontsizetick},
             }
        return sps

    def get_single_plot_struct(self):
        sps={'Layout_Position_HV':[1,1],
            'Layout_Size_RowCol':[1,1],
            'Plot_Title':{'Title':'Current I HF','Position':'Top','Fontsize':13},
            'Plot_Type':'scatter',
            'Axis_X': self.get_one_axis_struct('X',[-100,100],'X (mm)', [-80.0,80.0],True,90,5.0,12,False),
            'Axis_Y': self.get_one_axis_struct('Z',[0,100],'Z (mm)', [0.0,70.0],True,0,5.0,12,False),
            'Axis_Z': self.get_one_axis_struct('STAT_I_HF',[0,20],'I HF (A)',[8.0,16.0],False,90,5.0,12,False), 
            'Reverse_Data_Series':False,
            'Smooth_Data':'',
            'Predefined_Style':'',
            'Projection':{'Type':''},
            'Grid':{'Show_Grid':False,'Grid_which':'both','Grid_axis':'both','Use_Line_style':False,'Line_format':{'linewidth':1.0,'color':'gray','linestyle':'--'}},
            'Colormap':{'Colormap_Active':True,'Colormap_Type':'turbo','Colormap_Auto_Range': True,'Colormap_Range':[8,20],'Colormap_Reverse':False,'Colormap_Label':{'Colormap_Position':'right','Colormap_Show_Label':True,'Colormap_Label_align':'bottom','Fontsize_Label':12,'Rotation_Label':-90}},            
            'Plot_Legend':{'Legend_Active':True,'Box_anchor':[1.05,1.0],'Position':'upper left','Fontsize':13,'title':'','title_fontsize':15,'markerfirst':True,'frameon':True,'fancybox':True,'shadow':False,'framealpha':0.8,'facecolor':"inherit",'edgecolor':"inherit",'alignment':'center','ncols':1,'mode':None},
            'Contour':{'Show_value_Labels':True,'value_Labels_size':6,'Number_of_levels':-1,'Use_specific_Values':False,'Use_values':[0.0,10.0],'Use_colors':['r','g']},
            'Bar':{'Use_colors':['black','yellow'],'Bar_width':0.8,'Use_Lines_style':False,'logy':False,'align':'center'},
            'Lines':{'Complete_Vectors':False,'linewidth':[2.0],'color':['b'],'linestyle':[''],'dash_capstyle':'round','dash_joinstyle':'round', 'drawstyle':'default','Line_Marker':{'Use_Markers':False,'Marker_Type':['s'],'Marker_Size':[24],'markeredgecolor':['black'],'markeredgewidth':[0.8],'markerfacecolor':['black'],'markerfacecoloralt':['black']}},
            'Hist':{'bins':[50],'bins2':[50],'density':False,'cumulative':False,'histtype':'bar','hist_align':'mid','orientation':'vertical','relative_width':None,'log':False,'stacked':False,'Use_U_V_weights':False},
            'Quiver':{'angles':'xy','pivot':'tail','units':'width','inverse_scale':1.0,'scale_units':'xy','arrows':{'width':0.005,'headwidth':3.0,'headlength':5.0,'headaxislength':4.5,'minshaft':1.0,'minlength':1.0},'color':['black']},
            'Barbs':{'length':7,'pivot':'tip','barbcolor':['b'],'flagcolor':['b'],'sizes':{'spacing':2,'height':3,'width' :3,'emptybarb':1},'fill_empty':False,'rounding':True,'barb_increments':{'half':5,'full':10,'flag':50},'flip_barb':[False]},
            'Stream':{'density_xy':[1,1],'linewidth':['lwx=1.5','lwy=1.5'],'color':'b','start_points':'sp=None','arrows':{'arrowstyle':'-|>','arrowsize':3.0},'zorder':1,'minmaxlength':[0,1],'integration_direction':'both','broken_streamlines':True},
            'Eventplot':{'orientation':'vertical', 'lineoffsets':[1],'linelengths':[1], 'linewidths':[1.5], 'colors':[''], 'linestyles':['solid']},
            'Plot_Marker':{'Marker_Type':'s','Marker_Size':24},
            'Stem':{'bottom':0.0,'orientation':'vertical','Use_Lines_style':False,'linefmt':'C0-','markerfmt':'C2D','basefmt':'C3-'},
            'Stairs':{'edges':[None],'orientation':'vertical','baseline':[0.0],'Fill':False,'Use_Lines_style':False},
            'Stackplot':{'baseline':'zero','colors':['']},
            'Pie':{ 'explode':[0],'colors':[''], 'autopct':'', 'pctdistance':0.6, 'shadow':False, 'labeldistance':1.1, 'startangle':0, 'radius':1, 'counterclock':True, 'wedgeprops':{"width":1,"linewidth": 1, "edgecolor": "white"}, 'textprops':{'color':'black', 'weight':"bold",'size':8}, 'center':[0, 0], 'frame':False, 'rotatelabels':False, 'normalize':True}, 
            'Background':{'BG_Path_File':'','Show_Axis':True,'BG_Aspect':1,'BG_Out_Color':'None','BG_in_Color':'None','BG_out_alpha':1,'BG_in_alpha':1},
            'Error_bars':{'Use_Err_bars':False,'Err_Y_Use_key':'ErrUp=0.5','Err_X_Use_key':'ErrLow=0.5','fmt':'o','capthick':2.0,'barsabove':False,'elinewidth':2.0,'ecolor':'black','capsize':0.0,'errorevery_X':1,'errorevery_Y':1,'lolims':[False], 'uplims':[False], 'xlolims':[False], 'xuplims':[False]},
            'Additional':{'Axis_U': self.get_one_axis_struct('',[-100,100],'', [-80.0,80.0],True,90,5.0,12,True),'Axis_V': self.get_one_axis_struct('',[-100,100],'', [-80.0,80.0],True,90,5.0,12,True),'Axis_W': self.get_one_axis_struct('',[-100,100],'', [-80.0,80.0],True,90,5.0,12,True),'math_definitions':'cte=5|ctlst=[1,2,3]','math_declarations':['']},
            'Reference_Lines':{'Show_Ref_Lines':False,'Horizontal':{'Show_XLines':False,'Y_points':'Yp=[0,10]','Use_X_Range':True,'X_Min_Max':[0,1],'Line_format':{'linewidth':[1.0],'color':['gray'],'linestyle':['--']}},'Vertical':{'Show_YLines':False,'X_points':'Xp=range(0,11,1)','Use_Y_Range':True,'Y_Min_Max':[0,1],'Line_format':{'linewidth':[1.0],'color':['gray'],'linestyle':['--']}},'Radial':{'Show_EquiLines':False,'Equi_points':'Rp=[5,10,15]','ini_angle':0.0,'Use_Ang_Range':True,'Ang_Min_Max':[0,1],'Center_coord':[0.0,0.0,0.0],'Line_format':{'linewidth':[1.0],'color':['gray'],'linestyle':['--']}},'Angular':{'Show_RLines':False,'Angles':'Ap=range(0,360,15)','Use_R_Range':True,'R_Min_Max':[0,1],'Line_format':{'linewidth':[2.0],'color':['gray'],'linestyle':['--']}}}
            }
        return sps

    def get_one_plot_struct(self,theid=''):
        aops={'ID':theid,
              'Plot_Active':True,
              'Plot_User_Info':{'Creation_Date':str(datetime.datetime.now()),'Author':'FG'},
              'Plots':{'P1':self.get_single_plot_struct()},
              'Fig_Size':[13,12]}
        return aops
    
    def get_one_axis_struct_mask(self):
        typefloat=str(type(0.1))
        typeint=str(type(0))        
        oasm={'Axis_Data_Range': {'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2}, 
              'Axis_Scale_Range': {'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2},
              'Axis_Ticks':{'Rotation_Tick':{'__m__':'is_value_type','__mv__':typeint},'Step_Size_Tick':{'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GT','__mv__1':0},'Fontsize_Tick':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0}}
              }
        return oasm

    def get_one_plot_struct_mask(self):        
        cmlist=matplotlib.pyplot.colormaps()
        markerlist=self.get_dict_key_list(matplotlib.lines.Line2D.markers) #there are ints and str mixed :S
        markerlistmod=[]
        for mmm in markerlist:
            if type(mmm)==int:
                markerlistmod.append('int_'+str(mmm))
            else:
                markerlistmod.append(mmm)

        plottypelist=['image','scatter','contour','contourf','bar','barh','loglog','semilogx','semilogy','quiver','barbs','plot','hist','hist2d','errorbar','stem','streamplot','lines','eventplot','stackplot','stairs','specgram','phase_spectrum','magnitude_spectrum','pie'] #3D others surface, contour3D
        dashcapstylist=['butt', 'projecting', 'round']
        dashjoinstylist=['miter', 'round', 'bevel']
        drawstylelist=['default', 'steps', 'steps-pre', 'steps-mid', 'steps-post']
        projections=['','None','polar']
        #look https://matplotlib.org/stable/gallery/misc/set_and_get.html
        baralign=['center','edge']
        smoothtypelist=['cubic','bezier','None','',True,False]
        gridalist=['both', 'x', 'y']
        gridwlist=['major', 'minor', 'both']
        linestyle=['-', '--', '-.', ':', 'None', ' ', '', 'solid', 'dashed', 'dashdot', 'dotted']
        stackbaseline=['zero', 'sym', 'wiggle', 'weighted_wiggle']
        labelposlist=['best','upper right','upper left','lower left','lower right','right','center left','center right','lower center','upper center','center']
        colormapposlist=['left','right','top','bottom']
        colormaplabelalignlist=['top', 'bottom', 'center', 'baseline', 'center_baseline']
        histtypelist=['bar', 'barstacked', 'step', 'stepfilled']
        histalign=['left', 'mid', 'right']
        historientation=['vertical', 'horizontal']
        quiangles=['xy','uv']
        quiunits=['width', 'height', 'dots', 'inches', 'x', 'y', 'xy']
        quipivot=['tail', 'mid', 'middle', 'tip']  
        barbpivot=['tip', 'middle']   
        stream_intdir=['forward', 'backward', 'both']      
        legendmode=[None,'expand','']    
        legendalignment=['center', 'left', 'right'] 
        typefloat=str(type(0.1))
        typeint=str(type(0))
        typestr=str(type('hola'))
        typebool=str(type(True))
        Streamarrowstyle=['-','<-','->','<->','<|-','-|>','<|-|>',']-','-[',']-[','|-|',']->','<-[','simple','fancy','wedge']
        Streamarrowconnstyle=['','arc3','angle3','angle','arc','bar']
        try:
            availablestyles=['','None']
            matplotlib.pyplot.style.reload_library()
            availablestyles.extend(matplotlib.pyplot.style.available)
        except:
            availablestyles=['','None']
        minmaxrest={'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2,'__m__2':'is_list_item_value_GTEQ','__mv__2':0,'__m__3':'is_list_item_value_LTEQ','__mv__3':1}
        singlelinerestriction={'linewidth':{'__m__':'is_value_type','__mv__':typefloat},'linestyle':{'__m__':'is_value_type','__mv__':typestr,'__m__1':'limited_selection','__mv__1':linestyle}}
        linerestriction={'linewidth':{'__m__':'is_list_item_type','__mv__':typefloat},'color':{'__m__':'is_list_item_type','__mv__':typestr},'linestyle':{'__m__':'is_list_item_type','__mv__':typestr,'__m__1':'is_list_item_limited_selection','__mv__1':linestyle}}
        arrowrestdict={'width':{'__m__':'is_value_type','__mv__':typefloat},'headwidth':{'__m__':'is_value_type','__mv__':typefloat},'headlength':{'__m__':'is_value_type','__mv__':typefloat},'headaxislength':{'__m__':'is_value_type','__mv__':typefloat},'minshaft':{'__m__':'is_value_type','__mv__':typefloat},'minlength':{'__m__':'is_value_type','__mv__':typefloat}}
        msps={'Layout_Position_HV':{'__m__':'is_list_item_type','__mv__':typeint,'__m__1':'is_list_length','__mv__1':2,'__m__2':'is_list_item_value_GT','__mv__2':0}, 
              'Layout_Size_RowCol':{'__m__':'is_list_item_type','__mv__':typeint,'__m__1':'is_list_length','__mv__1':2,'__m__2':'is_list_item_value_GT','__mv__2':0}, 
              'Plot_Title':{'Fontsize':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0}},  
              'Plot_Type':{'__m__':'limited_selection','__mv__':plottypelist},
              'Axis_X': self.get_one_axis_struct_mask(),
              'Axis_Y': self.get_one_axis_struct_mask(),
              'Axis_Z': self.get_one_axis_struct_mask(),
              'Smooth_Data':{'__m__':'limited_selection','__mv__':smoothtypelist},
              'Predefined_Style':{'__m__':'limited_selection','__mv__':availablestyles},
              'Projection':{'Type':{'__m__':'limited_selection','__mv__':projections}},
              #'Annotate':{'text':[''],'position':[]},
              'Grid':{'Grid_which':{'__m__':'limited_selection','__mv__':gridwlist},'Grid_axis':{'__m__':'limited_selection','__mv__':gridalist},'Line_format':singlelinerestriction},
              'Colormap':{'Colormap_Type':{'__m__':'limited_selection','__mv__':cmlist},'Colormap_Range':{'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2},'Colormap_Label':{'Colormap_Position':{'__m__':'limited_selection','__mv__':colormapposlist},'Colormap_Label_align':{'__m__':'limited_selection','__mv__':colormaplabelalignlist}}},                            
              'Plot_Legend':{'Box_anchor':{'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2},'Position':{'__m__':'limited_selection','__mv__':labelposlist},'Fontsize':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'title':{'__m__':'is_value_type','__mv__':typestr},'title_fontsize':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'framealpha':{'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GTEQ','__mv__1':0,'__m__2':'is_value_LTEQ','__mv__2':1},'alignment':{'__m__':'limited_selection','__mv__':legendalignment},'ncols':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'mode':{'__m__':'limited_selection','__mv__':legendmode}},
              'Lines':{'linewidth':{'__m__':'is_list_item_type','__mv__':typefloat},'color':{'__m__':'is_list_item_type','__mv__':typestr},'linestyle':{'__m__':'is_list_item_type','__mv__':typestr,'__m__1':'is_list_item_limited_selection','__mv__1':linestyle},'dash_capstyle':{'__m__':'limited_selection','__mv__':dashcapstylist},'dash_joinstyle':{'__m__':'limited_selection','__mv__':dashjoinstylist}, 'drawstyle':{'__m__':'limited_selection','__mv__':drawstylelist},'Line_Marker':{'Marker_Type':{'__m__':'is_list_item_limited_selection','__mv__':markerlistmod},'Marker_Size':{'__m__':'is_list_item_type','__mv__':typeint},'markeredgecolor':{'__m__':'is_list_item_type','__mv__':typestr},'markeredgewidth':{'__m__':'is_list_item_type','__mv__':typefloat},'markerfacecolor':{'__m__':'is_list_item_type','__mv__':typestr},'markerfacecoloralt':{'__m__':'is_list_item_type','__mv__':typestr}}},
              'Contour':{'value_Labels_size':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'Number_of_levels':{'__m__':'is_value_type','__mv__':typeint},'Use_specific_Values':False,'Use_values':{'__m__':'is_list_item_type','__mv__':typefloat},'Use_colors':{'__m__':'is_list_item_type','__mv__':typestr}},  
              'Bar':{'Use_colors':{'__m__':'is_list_item_type','__mv__':typestr},'Bar_width':{'__m__':'is_value_GT','__mv__':0},'align':{'__m__':'limited_selection','__mv__':baralign}},
              'Hist':{'bins':{'__m__':'is_list_item_type','__mv__':typeint},'bins2':{'__m__':'is_list_item_type','__mv__':typeint},'histtype':{'__m__':'limited_selection','__mv__':histtypelist},'hist_align':{'__m__':'limited_selection','__mv__':histalign},'orientation':{'__m__':'limited_selection','__mv__':historientation}},
              'Quiver':{'angles':{'__m__':'limited_selection','__mv__':quiangles},'units':{'__m__':'limited_selection','__mv__':quiunits},'pivot':{'__m__':'limited_selection','__mv__':quipivot},'inverse_scale':{'__m__':'is_value_type','__mv__':typefloat},'scale_units':{'__m__':'limited_selection','__mv__':quiunits},'arrows':arrowrestdict},
              'Barbs':{'length':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'pivot':{'__m__':'limited_selection','__mv__':barbpivot},'sizes':{'spacing':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GTEQ','__mv__1':0},'height':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GTEQ','__mv__1':0},'width' :{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GTEQ','__mv__1':0},'emptybarb':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GTEQ','__mv__1':0}},'fill_empty':False,'rounding':True,'barb_increments':{'half':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'full':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'flag':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0}},'flip_barb':{'__m__':'is_list_item_type','__mv__':typebool}},
              'Stream':{'density_xy':{'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2},'linewidth':{'__m__':'is_list_item_type','__mv__':typestr,'__m__1':'is_list_length','__mv__1':2,'__m__2':'is_list_item_format','__mv__2':'(.+)=(.+?)$'},'start_points':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'arrows':{'arrowstyle':{'__m__':'limited_selection','__mv__':Streamarrowstyle},'arrowsize':{'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GTEQ','__mv__1':0}},'zorder':{'__m__':'is_value_type','__mv__':typeint},'minmaxlength':minmaxrest,'integration_direction':{'__m__':'limited_selection','__mv__':stream_intdir}},
              'Eventplot':{'orientation':{'__m__':'limited_selection','__mv__':historientation}, 'lineoffsets':{'__m__':'is_list_item_type','__mv__':typefloat},'linelengths':{'__m__':'is_list_item_type','__mv__':typefloat}, 'linewidths':{'__m__':'is_list_item_type','__mv__':typefloat}, 'linestyles':{'__m__':'is_list_item_type','__mv__':typestr,'__m__1':'is_list_item_limited_selection','__mv__1':linestyle},'colors':{'__m__':'is_list_item_type','__mv__':typestr}},
              'Stackplot':{'baseline':{'__m__':'limited_selection','__mv__':stackbaseline},'colors':{'__m__':'is_list_item_type','__mv__':typestr}},
              'Plot_Marker':{'Marker_Type':{'__m__':'limited_selection','__mv__':markerlistmod},'Marker_Size':{'__m__':'is_value_type','__mv__':typeint}},
              'Stem':{'bottom':{'__m__':'is_value_type','__mv__':typefloat},'orientation':{'__m__':'limited_selection','__mv__':historientation}},
              'Stairs':{'edges':{'__m__':'is_list_item_type','__mv__':typefloat},'orientation':{'__m__':'limited_selection','__mv__':historientation},'baseline':{'__m__':'is_list_item_type','__mv__':typefloat}},
              'Pie':{ 'explode':{'__m__':'is_list_item_type','__mv__':typefloat},'colors':{'__m__':'is_list_item_type','__mv__':typestr}, 'autopct':{'__m__':'is_value_type','__mv__':typestr}, 'pctdistance':{'__m__':'is_value_type','__mv__':typefloat}, 'labeldistance':{'__m__':'is_value_type','__mv__':typefloat}, 'startangle':{'__m__':'is_value_type','__mv__':typefloat}, 'radius':{'__m__':'is_value_type','__mv__':typefloat}, 'wedgeprops':{"width":{'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GT','__mv__1':0}, "linewidth": {'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GTEQ','__mv__1':0}, "edgecolor": {'__m__':'is_value_type','__mv__':typestr}}, 'textprops':{'Fontsize':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0}}, 'center':{'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':2}}, 
              'Error_bars':{'Err_Y_Use_key':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'Err_X_Use_key':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'capsize':{'__m__':'is_value_type','__mv__':typeint,'__m__':'is_value_GTEQ','__mv__':0.0},'capthick':{'__m__':'is_value_type','__mv__':typefloat},'elinewidth':{'__m__':'is_value_type','__mv__':typefloat},'capsize':{'__m__':'is_value_type','__mv__':typefloat},'errorevery_X':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'errorevery_Y':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'lolims':{'__m__':'is_list_item_type','__mv__':typebool}, 'uplims':{'__m__':'is_list_item_type','__mv__':typebool}, 'xlolims':{'__m__':'is_list_item_type','__mv__':typebool}, 'xuplims':{'__m__':'is_list_item_type','__mv__':typebool}},# 'fmt':{'__m__':'limited_selection','__mv__':markerlistmod}
              'Background':{'BG_Aspect':{'__m__':'is_value_type','__mv__':typeint,'__m__1':'is_value_GT','__mv__1':0},'BG_out_alpha':{'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GTEQ','__mv__1':0,'__m__2':'is_value_LTEQ','__mv__2':1},'BG_in_alpha':{'__m__':'is_value_type','__mv__':typefloat,'__m__1':'is_value_GTEQ','__mv__1':0,'__m__2':'is_value_LTEQ','__mv__2':1}},
              'Additional':{'Axis_U': self.get_one_axis_struct_mask(),'Axis_V': self.get_one_axis_struct_mask(),'Axis_W': self.get_one_axis_struct_mask(),'math_declarations':{'__m__':'is_list_item_type','__mv__':typestr,'__m__1':'is_list_item_format','__mv__1':'(.+)=(.+?)$'},'math_definitions':{'__m__':'is_format','__mv__':'([a-zA-Z_].*=.+)(|[a-zA-Z_].*=.+)*'}},
              'Reference_Lines':{'Horizontal':{'Y_points':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'X_Min_Max':minmaxrest,'Line_format':linerestriction},'Vertical':{'X_points':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'Y_Min_Max':minmaxrest,'Line_format':linerestriction},'Radial':{'ini_angle':{'__m__':'is_value_type','__mv__':typefloat},'Equi_points':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'Ang_Min_Max':minmaxrest,'Center_coord':{'__m__':'is_list_item_type','__mv__':typefloat,'__m__1':'is_list_length','__mv__1':3},'Line_format':linerestriction},'Angular':{'Angles':{'__m__':'is_format','__mv__':'(.+)=(.+?)$'},'R_Min_Max':minmaxrest,'Line_format':linerestriction}}
              }
        return msps

    def get_single_plot_struct_mask(self):
        spstr=self.get_one_plot_struct_mask()
        typefloat=str(type(0.5))
        typeint=str(type(0))
        typestr=str(type(''))
        dateformat='^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?'
        maops={'ID':{'__m__':'is_unique','__mv__':typestr},
               'Plot_User_Info':{'Creation_Date':{'__m__':'is_format','__mv__':dateformat}},
               'Plots':{'__any__':spstr},
               'Fig_Size':{'__m__':'is_list_item_type','__mv__':typeint,'__m__1':'is_list_length','__mv__1':2,'__m__2':'is_list_item_value_GT','__mv__2':0}}
        return maops




    def setupUi2(self, MainWindow):   
        # Add objects by code here additional to objects in GUI_PostProcessing
        # Or set configuration of objects  
        #initial conditions
        self.start_up()
        #------------- Mainwindow
        # set the icon           
        path_to_file=self.app_path+os.sep+"img"+os.sep+"Data-Scatter-Plot-icon.png"
        file_exists = os.path.exists(path_to_file)
        #print(path_to_file+' '+str(file_exists))
        self.iconMainpixmap=None
        self.iconMain=None        
        if file_exists==True:
            self.iconMainpixmap=QtGui.QPixmap(path_to_file)
            self.iconMain = QtGui.QIcon(QtGui.QPixmap(path_to_file))
            MainWindow.setWindowIcon(self.iconMain)   
            
        # set the title
        MainWindow.setWindowTitle("Plot Post Processing Tool by "+ __author__+" V"+__version__)
        MainWindow.showMaximized()
        #TextEdit stdout        
        self.textEdit.setReadOnly(True)
        self.textEdit.setFont(QtGui.QFont('Consolas', 11))
        #self.textEdit.setText('Test The console!')        

        self.R_Thread=Receiver_Thread(self.killer_event,a_queue)
        
        #Prefix line edit
        # Regex validator for text input
        strregex=QtCore.QRegExp("(\w*)")
        regexvalidator=QtGui.QRegExpValidator(strregex)
        self.lineEdit_Prefix.setValidator(regexvalidator)
        self.lineEdit_Prefix.setInputMask('')
        self.lineEdit_Prefix.setCursorPosition(0)
        self.lineEdit_Prefix.setMaxLength(20)
       
        #-----------Treeview 
        self.tvf=class_TreeViewFunctions.treeview_functions(self.treeView,self.plots_struct,self.plots_struct_mask,None,[])               
        self.model=self.tvf.modelobj
        self.tvf.data_change[list,str,str,str].connect(self.refresh_dialog_treeview)
        self.icons_dict={'Plots':self.iconMain} 
        #self.model = self.Create_Plot_Model_Treeview(self.treeView)                
        #self.tree.header().setDefaultSectionSize(180)                
        #self.Plot_importData_to_Tree(self.plots_struct)
        #self.importData(self.data)
        self.tvf.Expand_to_Depth(1)      
        self.tvf.set_Icons(self.icons_dict)    
        #-----------Splitter 
        self.set_splitter_pos(400,1/3) #initial position
        #-----------Right click Menu for treeview
        self.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)          
        #--------------
        self.set_path_labels()
        aDialog.set_default_dir(self.app_path)
        self.Connect_Actions()
        
        #after connecting
        #get last opened if in config
        self.open_last_files()
    
   

    def Connect_Actions(self):
        
        self.R_Thread.Receiver.mysignal.connect(self.append_text_to_text_edit)     

        self.actionOpen_CSV.triggered.connect(self.Open_CSV_File_d)
        self.actionSet_Results_Path_2.triggered.connect(self.Set_result_Path)
        self.actionSave_Plots_Structure.triggered.connect(self.Save_Plot_Struct_json)
        self.actionLoad_Plots_Structure.triggered.connect(self.Load_Plot_Struct_json_d)
        self.actionPlot_Structure_to_files.triggered.connect(lambda: self.Run_All_Active_Plot_Preview_Dialogs_tofile('.png'))
        self.actionPlot_Structure_to_pdf.triggered.connect(lambda: self.Run_All_Active_Plot_Preview_Dialogs_tofile('.pdf'))
        self.actionPlot_Preview_Structure.triggered.connect(self.Open_All_Active_Plot_Preview_Dialogs)
        self.actionAbout.triggered.connect(self.Show_aboutbox)
        self.actionPlot_Preview_Selected.triggered.connect(self.Open_Plot_Preview_Selected_Dialog)
        self.lineEdit_Prefix.textChanged.connect(self.lineedit_Set_prefix)

        #Treeview        
        
        #right click menu
        self.treeView.customContextMenuRequested.connect(self.listItemRightClicked)  
    
    # Right click Menu
    def listItemRightClicked(self, QPos): 
        self.listMenu= QtWidgets.QMenu()
        selindex=self.treeView.selectedIndexes()  
        try:                    
            indexitem=selindex[0]                 
        except:
            #makes error if clicks on the arrow with right click
            indexitem=None
            pass
            #return
        plotidlist=self.get_selected_plots_idlist()
        if len(plotidlist)==0:
            plotidlist=['']
        plottrack=self.get_selected_plot_track()
        if len(plottrack)==0:
            plottrack=['']
        if indexitem!=None:
            itm=indexitem.model().itemFromIndex(indexitem)  
            track=self.track_key_tree(itm)
        else:
            track=['']
        cp_track=self.CopyPaste_plot_dict['plot_track']
        log.debug('Rightclick Selected-> track {},plottrack {},plotidlist {}'.format(track,plottrack,plotidlist))        
        menu_item10 = self.listMenu.addAction("Plot Preview {}".format(track[0]))  
        self.listMenu.addSeparator()
        menu_item20 = self.listMenu.addAction("Add standard Item")
        menu_item21 = self.listMenu.addAction("Clone {}".format(track[0]))
        menu_item30 = self.listMenu.addAction("Delete {} Item".format(track[0]))
        self.listMenu.addSeparator()
        menu_item40 = self.listMenu.addAction("Add Plot to {}".format(track[0]))
        menu_item41 = self.listMenu.addAction("Clone Plot {}".format(plottrack))
        menu_item42 = self.listMenu.addAction("Copy Plot {}".format(plottrack))
        menu_item43 = self.listMenu.addAction("Paste Plot {}".format(cp_track))
        menu_item50 = self.listMenu.addAction("Delete Plot{}".format(plottrack))
        self.listMenu.addSeparator()
        menu_item60 = self.listMenu.addAction("Append Items from File")
        menu_item61 = self.listMenu.addAction("Save {} to File".format(track[0]))

        
        if track[0]=='':
            menu_item10.setEnabled(False)
            menu_item20.setEnabled(True)    #allow add Item
            menu_item21.setEnabled(False)
            menu_item30.setEnabled(False)            
            menu_item40.setEnabled(False)
            menu_item41.setEnabled(False)
            menu_item42.setEnabled(False)
            menu_item43.setEnabled(False)
            menu_item50.setEnabled(False)
            menu_item60.setEnabled(True)
            menu_item61.setEnabled(False)
        elif track[0]!='' and plottrack[0]=='':
            menu_item10.setEnabled(True)  
            menu_item20.setEnabled(True)  
            menu_item21.setEnabled(True)
            menu_item30.setEnabled(True)
            menu_item40.setEnabled(True) # Add new only when no plot selected
            menu_item41.setEnabled(False) # no plot clone
            menu_item42.setEnabled(False) 
            if len(cp_track)==0:   #something to paste        
                menu_item43.setEnabled(False)
            else:
                menu_item43.setEnabled(True)
            menu_item50.setEnabled(False)
            menu_item60.setEnabled(True)
            menu_item61.setEnabled(True)
        elif track[0]!='' and plottrack[0]!='':
            menu_item10.setEnabled(True)  
            menu_item20.setEnabled(False)  
            menu_item21.setEnabled(False)
            menu_item30.setEnabled(False)
            menu_item40.setEnabled(False) # Add new only when no plot selected
            menu_item41.setEnabled(True)  # plot clone
            menu_item42.setEnabled(True)
            if len(cp_track)==0:   #something to paste        
                menu_item43.setEnabled(False)
            else:
                menu_item43.setEnabled(True)
            menu_item50.setEnabled(True)
            menu_item60.setEnabled(True)
            menu_item61.setEnabled(False)
        

        menu_item10.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,10))            
        menu_item20.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,20))            
        menu_item21.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,21))
        menu_item30.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,30)) 
        menu_item40.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,40)) 
        menu_item41.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,41))
        menu_item42.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,42))
        menu_item43.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,43))
        menu_item50.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,50)) 
        menu_item60.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,60)) 
        menu_item61.triggered.connect(lambda: self.RCmenuItemClicked(indexitem,61)) 


        parentPosition = self.treeView.mapToGlobal(QtCore.QPoint(0, 0))        
        self.listMenu.move(parentPosition + QPos)
        self.listMenu.show() 

    def RCmenuItemClicked(self,indexitem,menuitem):
        
        if menuitem==10:            
            self.Open_Plot_Preview_Selected_Dialog()
        elif menuitem==20:
            self.add_new_standard_plotitem()
        elif menuitem==21:
            self.addclone_new_plotitem()
        elif menuitem==30:
            self.delete_plotitem()
        elif menuitem==40:
            self.add_plot_to_item()
        elif menuitem==41:
            self.add_plot_to_item()
        elif menuitem==42:
            self.Copy_plot_track()
        elif menuitem==43:
            self.Paste_from_plot_track()            
        elif menuitem==50:
            self.delete_plot()
        elif menuitem==60:
            self.Load_Append_Plot_Struct_json()
        elif menuitem==61:            
            self.Save_Item_to_json()            
        else:
            itm=indexitem.model().itemFromIndex(indexitem)  
            track=self.track_key_tree(itm)
            #print('Right item Menu track: ',track)
    
    
    def Copy_plot_track(self):
        plottrack=self.get_selected_plot_track()
        log.info('{} plot copied to Clipboard!'.format(plottrack))
        self.CopyPaste_plot_dict.update({'plot_track':plottrack})
    
    def Paste_from_plot_track(self):
        plotidlist=self.get_selected_plots_idlist()
        cp_track=self.CopyPaste_plot_dict['plot_track']
        log.info('{} plot Pasted to {}!'.format(cp_track,plotidlist))
        self.add_plot_to_item(cp_track)
        self.Clear_Copypaste_plot_track()

    def Clear_Copypaste_plot_track(self):        
        self.CopyPaste_plot_dict.update({'plot_track':[]})

    #----------------------------------------------------------------
    def is_id_taken(self, id):
        idlist=self.get_id_list()
        if id in idlist:
            return True
        else:
            return False

    def get_unique_id(self,desired_id):
        if self.is_id_taken(desired_id)==False and desired_id!='' and desired_id!=None:
            return desired_id
        else:
            if desired_id==None or desired_id!='':
                desired_id='UID_'
            iii=1
            copydid=desired_id+str(iii)            
            while self.is_id_taken(copydid)==True:
                iii=iii+1
                copydid=desired_id+str(iii)
            return copydid



    
    def get_id_list(self,plot_struct=None):
        if plot_struct==None:
            plot_struct=self.plots_struct
        idlist=[]
        for item in plot_struct:
            idlist.append(item['ID'])
        return idlist

    def get_struct_from_id(self,The_id):
        for item in self.plots_struct:
            if item['ID']==The_id:
                return self.recursive_copy_dict(item)#item.copy()
    
    def recursive_copy_dict(self,indict):
        outdict={}
        if self.is_dict(indict):
            keylist=self.get_dict_key_list(indict)
            for iii in keylist:
                if self.is_dict(indict[iii])==True:
                    outdict.update({iii:self.recursive_copy_dict(indict[iii])})                
                else:
                    outdict.update({iii:indict[iii]})
        else:    
            outdict=indict
        return outdict
    
    def del_struct_with_id(self,The_id):
        iii=0
        for item in self.plots_struct:
            if item['ID']==The_id:                
                self.plots_struct.pop(iii)
                log.info('Deleted Item {}!'.format(The_id))
            iii=iii+1

    def Save_Item_to_json(self):
        selindex=self.treeView.selectedIndexes() 
        if len(selindex)!=0:
            plotidlist=self.get_selected_plots_idlist()
            toSaveplots_struct=[]
            itemslist=[]
            for Plot_ID in plotidlist:        
                newitm=self.get_struct_from_id(Plot_ID)
                newitmid=newitm['ID']                
                itemslist.append(newitmid)
                toSaveplots_struct.append(newitm)
            didsave=self.Save_any_Struct_json(toSaveplots_struct,tofile=None)
            if didsave==True:
                log.info('Successfully saved {} Item!'.format(itemslist))            

    def addclone_new_plotitem(self):
        selindex=self.treeView.selectedIndexes() 
        if len(selindex)==0:            
            self.add_new_standard_plotitem()
        else:
            plotidlist=self.get_selected_plots_idlist()
            for Plot_ID in plotidlist:        
                newitm=self.get_struct_from_id(Plot_ID)
                newitmid=self.get_unique_id(newitm['ID'])
                newitm.update({'ID':newitmid})
                self.plots_struct.append(newitm)
                log.info('Successfully cloned {} Item to {}!'.format(Plot_ID,newitmid))
            self.refresh_Treeview()
            
    
    def add_new_standard_plotitem(self):        
        aops=self.get_one_plot_struct(self.get_unique_id(''))
        self.plots_struct.append(aops)
        self.refresh_Treeview()
        log.info('Successfully added a new Item!')
    
    def add_plot_to_id(self,theid,plottrack=[]):
        pdict={}
        for items in self.plots_struct:
            if items['ID']==theid:
                pdict=items['Plots']
                iii=1
                ppp='P'+str(iii)
                while ppp in pdict:
                    iii=iii+1
                    ppp='P'+str(iii)  
                if len(plottrack)==0:   
                    plottrack=self.get_selected_plot_track()               
                if plottrack==[]:
                    astruct=self.get_single_plot_struct()                    
                    pdict.update({ppp:self.recursive_copy_dict(astruct)})
                    log.info('Successfully added standard plot {} to {}!'.format(ppp,theid))
                else:
                    plotstruct=self.get_tracked_value_in_dict(plottrack)
                    pdict.update({ppp:self.recursive_copy_dict(plotstruct)})
                    #refresh in open dialogs    
                    newplottrack=plottrack.copy()
                    newplottrack.pop(len(plottrack)-1)
                    newplottrack.append(ppp)
                    #print('the newtrack:',newplottrack)
                    newplotstruct=self.get_tracked_value_in_dict(newplottrack)                    
                    atype=str(type(newplotstruct))
                    if atype==str(type([])):
                        subtype=self.tvf.get_listitem_subtype(newplottrack)
                    else:
                        subtype=''                        
                    #log.debug('Plot added-->{} {} {}'.format(newplottrack,atype,subtype))
                    log.info('Plot successfully added {}'.format(newplottrack))
                    self.refresh_dialog_treeview(newplottrack,newplotstruct,atype,subtype)
        #changed dictionary to treeview
        self.tvf.Plot_struct=self.plots_struct
        self.tvf.set_show_dict()

    def delete_plot(self):
        pdict={}        
        plottrack=self.get_selected_plot_track()   
        #print('plottrack->',plottrack)            
        if plottrack!=[]:
            delplot=self.send_questionYesNo_msgbox('Delete Plot','Are you sure you want to delete plot '+plottrack[2]+' from '+ plottrack[0] +'?')
            if delplot==True:
                for items in self.plots_struct:
                    if items['ID']==plottrack[0]:
                        pdict=items
                        break 
                #delete it               
                pdict[plottrack[1]].pop(plottrack[2])     
                log.info('Deleted Plot {}!'.format(plottrack))  
                #changed dictionary to treeview
                self.tvf.Plot_struct=self.plots_struct
                self.tvf.set_show_dict()
                #refresh in opened dialogs    
                newplottrack=plottrack.copy()
                newplottrack.pop(len(plottrack)-1)                                
                newplotstruct=self.get_tracked_value_in_dict(newplottrack)
                for aplot in newplotstruct:
                    ntrack=[]
                    ntrack.extend(newplottrack)
                    ntrack.append(aplot)                   
                    #sets a dictionary as a string so need to pass all elements separately
                    atype=str(type(newplotstruct[aplot]))
                    if atype==str(type([])):
                        subtype=self.tvf.get_listitem_subtype(ntrack)
                    else:
                        subtype=''                    
                    #print('del-->',ntrack,atype,subtype)                    
                    self.refresh_dialog_treeview(ntrack,newplotstruct[aplot],atype,subtype)                                       
                
        self.refresh_Treeview()
 
    
    def get_selected_plot_track(self):
        selindex=self.treeView.selectedIndexes() 
        plottrack=[]
        for selection in selindex:
            itm=selection.model().itemFromIndex(selection)   
            track=self.track_key_tree(itm)
            modtrack=[]
            if 'Plots' in track and len(track)>2:
                modtrack.append(track[0])#add id
                modtrack.append(track[1])#plots                                
                modtrack.append(track[2])#plot   
                plottrack=modtrack                             
                break                
        return plottrack

    def add_plot_to_item(self,plottrack=[]):        
        plotidlist=self.get_selected_plots_idlist()       
        for Plot_ID in plotidlist:
            self.add_plot_to_id(Plot_ID,plottrack)
        self.refresh_Treeview()

    def delete_plotitem(self):
        plotidlist=self.get_selected_plots_idlist()
        for Plot_ID in plotidlist:                
            delplot=self.send_questionYesNo_msgbox('Delete Item','Are you sure you want to delete Item '+Plot_ID+'?')
            if delplot==True:
                self.del_struct_with_id(Plot_ID)                
            else:
                pass
        self.refresh_Treeview()

    def get_selected_plots_idlist(self):
        selindex=self.treeView.selectedIndexes() 
        plotidlist=[]
        for selection in selindex:
            itm=selection.model().itemFromIndex(selection)   
            track=self.track_key_tree(itm)
            Plot_ID=self.get_tracked_value_in_dict([track[0],'ID']) 
            if Plot_ID not in plotidlist:
                plotidlist.append(Plot_ID)
        return plotidlist

    def Create_container_for_dialogs(self):
        try:
            Dialogitems=len(self.open_Dialogs)
        except:
            self.open_Dialogs={}
            Dialogitems=0
            pass

    def Run_All_Active_Plot_Preview_Dialogs_tofile(self,filetype='.png'):
        #Create container for dialogs
        self.Create_container_for_dialogs()        
        try:
            if self.Data_avilable==False:
                self.send_informative_msgbox('No data Available','Please open a File with data first!')
                return
            idlist=self.get_id_list(self.plots_struct)
            activelist=[]        
            for id_item in idlist:
                track=[id_item,'Plot_Active']
                #itemdict=self.get_tracked_value_in_dict([id_item,'ID'])
                is_active=self.get_tracked_value_in_dict(track)                                
                #log.info('--- {} {} \n {}'.format(track,is_active,itemdict))
                activelist.append(is_active)   
            #log.info('{}'.format(activelist))                     
            dt=datetime.datetime.now()
            savedlist=[]
            now='{}_'.format(dt.strftime('%Y-%m-%d_%H-%M'))
            for id_item,id_active in zip(idlist,activelist):
                if id_active==True:
                    self.Open_dialog_with_id(id_item,False)
                    medialog=self.open_Dialogs[id_item] 
                    medialog.DPPui.checkBox_Show_Figure.setChecked(False)
                    medialog.generate_plot_preview()
                    fig=medialog.FigPreview                    
                    fname=now+id_item
                    if type(fig)==type(None):
                        log.error('Issues with {} plot!. Figure is not saved!'.format(id_item))
                        continue
                    else:
                        rfilename=medialog.Save_figure_to_file(fig,filepath=self.des_res_path,plotname=fname,fileext=filetype)#,transparent_=False,aspect='tight',margin=1
                        if os.path.exists(rfilename)==True:
                            savedlist.append(fname+filetype)
            for rfn in savedlist:
                log.info('++++++++++++ Successfully saved {} plot!'.format(rfn))
        except Exception as e:
            log.error('Could not run all plot structures: {}'.format(e))

    def Open_All_Active_Plot_Preview_Dialogs(self): 
        #Create container for dialogs
        self.Create_container_for_dialogs()
        try:
            if self.Data_avilable==False:
                self.send_informative_msgbox('No data Available','Please open a File with data first!')
                return
            idlist=self.get_id_list(self.plots_struct)
            activelist=[]        
            for id_item in idlist:
                is_active=self.tvf.str_to_bool(self.get_tracked_value_in_dict([id_item,'Plot_Active']))
                activelist.append(is_active)
            for id_item,id_active in zip(idlist,activelist):
                if id_active==True:
                    self.Open_dialog_with_id(id_item) 
        except Exception as e:
            log.error('Could not open all plot structures: {}'.format(e))
        
    def Open_Plot_Preview_Selected_Dialog(self):       
        if self.Data_avilable==True:
            selindex=self.treeView.selectedIndexes() 
            #Create container for dialogs
            self.Create_container_for_dialogs()
            if len(selindex)==0:
                self.send_informative_msgbox('No item selected to plot','Select Item(s) to plot in the Treeview')            
            else:
                selection=selindex[0]
            #log.info('selindex {}'.format(selindex)) #is opening several windows with the for
            #for selection in selindex:                
                itm=selection.model().itemFromIndex(selection)   
                track=self.track_key_tree(itm)
                Plot_ID=self.get_tracked_value_in_dict([track[0],'ID'])                 
                self.Open_dialog_with_id(Plot_ID)         
        else:
            self.send_informative_msgbox('No data Available','Please open a File with data first!')

    def Open_dialog_with_id(self,Plot_ID,Showdialog=True):
        Plot_struct=self.plots_struct
        Plot_struct_mask=self.plots_struct_mask
        csv_data=self.df
        PPDialog=class_PlotPreview.PlotPreviewDialog(Plot_ID,Plot_struct,csv_data,Plot_struct_mask)        
        PPDialog.plot_structure_changed[list,str,str,str].connect(self.Plot_setting_changed)
        PPDialog.plot_dialog_closing[str].connect(self.unlist_a_dialog)
        self.open_Dialogs.update({Plot_ID:PPDialog})
        if Showdialog==True:
            PPDialog.Dialog_PrintPreview.show()

    def Plot_setting_changed(self,track,val,valtype,subtype):
        log.info('Main got info: {} {} {} {}'.format(track,val,valtype,subtype))
        valwt=self.tvf.set_type_to_value(val,valtype,subtype)
        self.set_tracked_value_to_dict_local(track,valwt,subtype)        
        self.refresh_Treeview()
        self.tvf.Expand_to_Depth(1)
        self.plot_structure_changed(True)
        #self.treeView.expandAll()
    
    def Save_any_Struct_json(self,tosavestruct,tofile=None):  
        saved=False
        if tofile==None:      
            filename =aDialog.saveFileDialog(8)        
        if filename!=None:
            fn=self.extract_filename(filename,False)+'.json'
            path=self.extract_path(filename)
            aDialog.set_default_dir(path)
            filename=os.path.join(path,fn)         
            try:   
                # python dictionary with key value pairs
                dict = tosavestruct
                # create json object from dictionary
                js = json.dumps(dict)
                # open file for writing, "w" 
                f = open(filename,"w")
                # write json object to file
                f.write(js)
                # close file
                f.close()
                log.info("Saved Items File:"+filename)
                saved=True
            except Exception as e:
                saved=False
                log.error("Json File :"+filename+ ' was not saved for item!')
                log.error(e)
        return saved

    def Save_Plot_Struct_json(self):        
        filename =aDialog.saveFileDialog(8)
        if filename!=None:
            fn=self.extract_filename(filename,False)+'.json'
            path=self.extract_path(filename)
            aDialog.set_default_dir(path)
            filename=os.path.join(path,fn)         
            try:   
                # python dictionary with key value pairs
                dict = self.plots_struct
                # create json object from dictionary
                js = json.dumps(dict)
                # open file for writing, "w" 
                f = open(filename,"w")
                # write json object to file
                f.write(js)
                # close file
                f.close()
                log.info("Saved File:"+filename)
                self.last_opened['last_opened_json']=filename
                self.set_last_opened_yml_file()
                self.plot_structure_changed(False)
            except Exception as e:
                log.error("Json File :"+filename+ ' was not saved')
                log.error(e)

    def Load_Plot_Struct_json_d(self):
        self.Load_Plot_Struct_json(None)

    def Load_Plot_Struct_json(self,afn=None):  
        if afn==None:      
            filename =aDialog.openFileNameDialog(8)
        else:
            filename=afn
        if filename!=None:
            path=self.extract_path(filename)
            aDialog.set_default_dir(path)
            try:                
                with open(filename) as f:
                    data = f.read()            
                #print("Data type before reconstruction : ", type(data))                
                # reconstructing the data as a dictionary
                js = json.loads(data)     
                self.close_dialogs()       
                #print("Data type after reconstruction : ", type(js))
                #print(js)
                log.info("Loaded File:"+filename)
                #self.plots_struct=js                
                self.plots_struct=self.Add_missing_dictionaries(js)
                self.close_dialogs()
                self.refresh_Treeview()
                self.last_opened['last_opened_json']=filename
                self.plot_structure_changed(False)
                self.set_last_opened_yml_file()
            except Exception as e:
                log.error("Json File :"+filename+ ' can not be opened')
                log.error(e)
    
    def Load_Append_Plot_Struct_json(self,afn=None):  
        if afn==None:      
            filename =aDialog.openFileNameDialog(8)
        else:
            filename=afn
        if filename!=None:
            path=self.extract_path(filename)
            aDialog.set_default_dir(path)
            try:                
                with open(filename) as f:
                    data = f.read()            
                #print("Data type before reconstruction : ", type(data))                
                # reconstructing the data as a dictionary
                js = json.loads(data)            
                #print("Data type after reconstruction : ", type(js))
                #print(js)
                log.info("Loaded Append File:"+filename)
                #self.plots_struct=js                
                Append_plots_struct=self.Add_missing_dictionaries(js)
                #Add to struct:
                Appendidslist=self.get_id_list(Append_plots_struct)
                plotidlist=self.get_selected_plots_idlist()
                for Plot_ID,newitm in zip(Appendidslist,Append_plots_struct):                            
                    newitmid=self.get_unique_id(Plot_ID)
                    newitm.update({'ID':newitmid})
                    self.plots_struct.append(newitm)
                    log.info('Successfully appended {} Item as {}!'.format(Plot_ID,newitmid))            
                self.refresh_Treeview()                
                self.plot_structure_changed(True)                
            except Exception as e:
                log.error("Json File :"+filename+ ' can not be opened to Append')
                log.error(e)


    def plot_structure_changed(self,has_changed):
        self.has_Changed_PlotStructure=has_changed
        self.Set_Plots_gb_Name()

    def Set_Plots_gb_Name(self):
        fff=self.last_opened['last_opened_json']
        jsFilename=''
        if fff!="" and fff!=None:
            try:
                jsFilename=aDialog.extract_filename(fff,True)
            except:
                jsFilename=''
        if self.has_Changed_PlotStructure==False:
            self.groupBox_Plots.setTitle("Plots Structure {}".format(jsFilename))
        else:            
            self.groupBox_Plots.setTitle("Plots Structure {}*".format(jsFilename))
        

    def Add_missing_dictionaries(self,inc_struct):        
        newstruct=[]
        astruct=inc_struct.copy()
        for adict in astruct:
            sss=self.get_one_plot_struct('__Sample__')        
            baseplot=sss['Plots']['P1']
            for aplot in adict['Plots']:
                sss['Plots'].update({aplot:baseplot})
            moddict=self.add_missing_keys_dict(sss,adict,[adict['ID']])                    
            newstruct.append(moddict)
        return newstruct

    def add_missing_keys_dict(self,basedict,adict,metrack=[]):
        complete_dict={}
        for anitem in basedict:            
            newtrack=[]
            try:
                newtrack.extend(metrack)
                newtrack.append(anitem)
                #print(newtrack)
                the_item=adict[anitem]
                if self.is_dict(basedict[anitem])==True:
                    if self.is_dict(the_item)==True:
                        the_item=self.add_missing_keys_dict(basedict[anitem],the_item,newtrack)
                    else:
                        #if the item is not a dict but it should be a dictionary
                        log.info('{} Should be a dictionary. {} Structure replaced!'.format(anitem,newtrack))
                        the_item=basedict[anitem]                    
            except:                
                the_item=basedict[anitem]
                log.info('Added Missing Plot structure {} item: {}'.format(newtrack,anitem))
            complete_dict.update({anitem:the_item})
        return complete_dict.copy()


    def set_splitter_pos(self,pos,per=None):
        sizes=self.splitter.sizes()
        tot=sizes[1]+sizes[0]
        if per!=None and per>=0 and per<=1:            
            pos=int(tot*per)
            newsizes=[pos,tot-pos]
            self.splitter.setSizes(newsizes)
        elif pos<=tot:            
            newsizes=[pos,tot-pos]            
            self.splitter.setSizes(newsizes)
        self.splitter.adjustSize()

    def track_key_tree(self,anitem):
        track=[]
        anitemindex=anitem.index()
        indexitem=anitemindex.siblingAtColumn(0)
        track.append(indexitem.model().itemFromIndex(indexitem).text())        
        item=indexitem.model().itemFromIndex(indexitem)
        parent=item.parent()
        while parent!=None:
            try:
                track.append(parent.text())
                item=parent
                parent=item.parent()
            except:                
                pass  
        track.reverse()          
        return track

    def str_to_list(self,astr):        
        try:            
            sss=astr.strip("[")
            sss=sss.strip("]")
            splited=sss.split(",")
        except:
            return None
        return splited
    
    def set_tracked_value_to_dict_local(self,track,val,subtype):
        #print('set tracked main',track,val,str(type(val)))
        _,self.plots_struct=self.tvf.set_tracked_value_to_dict(track,val,self.plots_struct,subtype)
        #return self.tvf.set_tracked_value_to_dict(track,val,self.plots_struct,subtype)
        
    def refresh_Treeview(self):        
        self.tvf.refresh_Treeview(self.plots_struct,self.model,self.treeView)  
        self.model=self.tvf.treeviewobj.model()      
        

    def refresh_dialog_treeview(self,track,val,valtype,subtype):   
        #Change Main dictionary first
        _,self.plots_struct=self.tvf.set_tracked_value_to_dict(track,val,self.plots_struct,subtype,emitsignal=False)     
        #log.debug('Refresh dialog tv main dictval -> {} val->{}'.format(self.get_tracked_value_in_dict(track),val))
        #Change all other opened dialogs
        listofdialogs=self.get_dict_key_list(self.open_Dialogs)
        #print('refresh_dialog->',listofdialogs)
        # ID special case
        if len(track)==2:
            if track[1]=='ID':                
                if track[0]!=val:
                    #if dialog open close it
                    self.close_a_dialog(track[0])
                    #force name in struct
                    self.set_id_to_struct(track[0],val)
                    if track[0] in listofdialogs:
                        #if was open reopen it with new name
                        self.Open_dialog_with_id(val)                                                                                            
                    self.refresh_Treeview()      
                    return              

        listofdialogs=self.get_dict_key_list(self.open_Dialogs)            
        log.debug('Entered refresh dialogs track {} , val {}\n,valtype {}, listofdialogs {}'.format(track,val,valtype,listofdialogs))         
        if track[0] in listofdialogs:
            try:                
                open_dial=self.open_Dialogs[track[0]]    
                if valtype==str(type({})):
                    if self.is_dict(val)==True:
                        valwt=val
                    else:
                        valwt=json.loads(val)
                else:             
                    valwt=open_dial.tvf.set_type_to_value(val,valtype,subtype)
                _,open_dial.tvf.Plot_struct=open_dial.tvf.set_tracked_value_to_dict(track,valwt,open_dial.tvf.Plot_struct,subtype,emitsignal=False)                
                localtrack=open_dial.get_local_dict_track(track)
                
                #open_dial.Plot_struct=self.plots_struct
                open_dial.update_Plot_dict()                                                
                log.info('Updated dialog dict {}, {}'.format(track[0],localtrack))                
                if len(localtrack)>0 and track[0]==open_dial.Plot_ID: #if modified is in the local show treeview
                    log.info('Updated treeview dict {}'.format(track[0]))
                    _,open_dial.tvf.Show_dict=open_dial.tvf.set_tracked_value_to_dict(localtrack,valwt,open_dial.tvf.Show_dict,subtype,emitsignal=True)
                    open_dial.refresh_Treeview()
                    
                
            except Exception as e:
                log.error(e)
                pass        
        #show changes in treeview        
        self.plot_structure_changed(True)
    
    def set_id_to_struct(self,oldid,newid):
        for item in self.plots_struct:
            if item['ID']==oldid:
                item['ID']=newid

    def get_tracked_value_in_dict(self,track):
        trval=self.tvf.get_tracked_value_in_struct(track,self.plots_struct)
        if self.is_dict(trval)==True:
            return trval.copy() #return copy for it to be unique
        else:
            return trval
        
    def get_dict_key_list(self,dict):
        alist=[]
        for key in dict:
            alist.append(key)
        return alist
    
    def is_dict(self,var):
        if type(var)==dict:
            return True
        else:
            return False

    def is_list(self,var):
        if type(var)==list:
            return True
        else:
            return False

    def set_path_labels(self):        
        self.label_csv_File.setText('CSV File name:'+self.csv_file_name)
        self.label_csv_File.adjustSize()
        self.label_results_folder_path.setText('Result Folder Path:'+self.des_res_path)    
        self.label_results_folder_path.adjustSize()
        self.frame_5.adjustSize()

    def lineedit_Set_prefix(self):        
        self.prefix=self.lineEdit_Prefix.text()

    def dict_to_Tree(self,adict,myparent=None):                          
        if self.is_dict(adict)==True:                             
            key_list=self.get_dict_key_list(adict)
            iii=0
            for akey in key_list:
                if myparent==None:                                                            
                    parent = self.model.invisibleRootItem()                             
                else:                
                    parent=myparent
                childitem = QtGui.QStandardItem(akey)  
                emptyitem = QtGui.QStandardItem('')  
                value = adict[akey]    
                typeitem= QtGui.QStandardItem(str(type(value)))                                          
                if self.is_dict(value)==True:   
                    parent.appendRow([childitem,emptyitem,typeitem])
                    self.dict_to_Tree(value,childitem)
                else:                    
                    valueitem = QtGui.QStandardItem(str(value))                     
                    parent.appendRow([childitem,valueitem,typeitem]) #self.model.setItem(iii,0,child)
                iii=iii+1
                self.treeView.setFirstColumnSpanned(iii,self.treeView.rootIndex(),True)
   
    def get_general_config(self):
        thepath=self.app_path+os.sep+'cfg_plot.yml'        
        return self.open_configuration_yml_file(thepath)

    def get_last_opened_yml_file(self):        
        last_opened_csv=self.General_Config['last_opened_csv']
        last_opened_json=self.General_Config['last_opened_json']
        return last_opened_csv,last_opened_json

    def set_last_opened_yml_file(self):        
        last_opened_csv=self.last_opened['last_opened_csv']
        last_opened_json=self.last_opened['last_opened_json']
        self.General_Config['last_opened_csv']=last_opened_csv
        self.General_Config['last_opened_json']=last_opened_json
        try:
            if os.path.exists(self.path_config_file)==True:
                with open(self.path_config_file, 'w') as file:
                    yaml.dump(self.General_Config, file)
        except Exception as e:
            log.error('Saving yml configuration file!')
            log.error(e)

    def open_configuration_yml_file(self,path_config_file):        
        path_config=''
        
        try:
            with open(path_config_file) as file:
                path_config = yaml.load(file, Loader=yaml.SafeLoader)
                log.info("Environment configuration loaded") 
                self.path_config_file=path_config_file       
        except FileNotFoundError:
            log.error("Environment configuration file not found at "+ path_config_file )
            self.send_critical_msgbox('Configuration File not Found!','Please select location of configuration File' )            
            errpath=aDialog.openFileNameDialog(7) #7->yml Files (*.yml)
            if errpath==None:
                with open(errpath) as file:
                    path_config = yaml.load(file, Loader=yaml.SafeLoader)
                    log.info("Environment configuration loaded") 
                    log.warning('Save configuration path as {} to not be prompted for a file'.format(self.app_path+os.sep+'cfg_plot.yml'))                                 
            else:
                raise
            #print(f"Create new {config_file} file?")                
            #input_config(config_parameters)
            #generate_config_file(config_parameters)                    
        return path_config
   
    def get_path_images(self):
        path_images=self.General_Config['path_images']        
        path_im=os.path.join(self.app_path,path_images)
        if os.path.exists(path_im)==True:
            #print('folder found',path_im)
            return path_im
        else:
            self.send_critical_msgbox('No Image Folder','Please check Image folder exists in '+ path_im)
            raise
    
    def Set_result_Path(self):  
        listselected=aDialog.getOpenFilesAndDirs(caption='Select Folder or a File in the Folder',directory=self.csv_file_path)  
        if len(listselected)>0:
            if os.path.isdir(listselected[0])==True:  
                txt=listselected[0].replace('/',os.sep)              
                txt=txt.replace('\\',os.sep)              
                pathfn=os.path.join(txt,'') # is giving mixed \ and / formats mixed
            elif os.path.isfile(listselected[0])==True:
                pathfn=self.extract_path(listselected[0])
            self.des_res_path=pathfn
            
        self.set_path_labels()
        #print(self.des_res_path)    
        #self.send_informative_msgbox('Open a CSV file first','Please open first a csv file. By default the "results" folder will be located in the same csv path.')
    
    def send_questionYesNo_msgbox(self,title,amsg):
        msgbox = QtWidgets.QMessageBox()
        result = QtWidgets.QMessageBox.question(msgbox,
                      title,
                      amsg,
                      QtWidgets.QMessageBox.Yes| QtWidgets.QMessageBox.No)        
        if result == QtWidgets.QMessageBox.Yes:
            return True
        if result == QtWidgets.QMessageBox.No:
            return False
        return None

    def send_critical_msgbox(self,title,amsg):
        msgbox = QtWidgets.QMessageBox()
        msgbox.setWindowTitle(title)
        msgbox.setIcon(QtWidgets.QMessageBox.Critical)
        msgbox.setText(amsg)            
        msgbox.exec_()

    def send_informative_msgbox(self,title,amsg):
        msgbox = QtWidgets.QMessageBox()
        msgbox.setWindowTitle(title)
        msgbox.setIcon(QtWidgets.QMessageBox.Information)
        msgbox.setText(amsg)            
        msgbox.exec_()
    
    def Show_aboutbox(self):
        title='About Plot Post Processing Tool'
        amsg='<h1 style="font-size:160%;color:red;">Programmed with love</h1>'+'<h1 style="font-size:160%;color:black;">by '+ __author__+'</h1> <p style="color:black;">github: '+__gitaccount__+'</p> <p style="color:black;"> Current version: V'+__version__+'</p> <p style="color:black;">Creation date: '+__creationdate__+"</p>"
        #msgbox = QtWidgets.QMessageBox.about(MainWindow,title,amsg)        
        msgbox = QtWidgets.QMessageBox()
        msgbox.setWindowTitle(title)
        #msgbox.setIcon(QtWidgets.QMessageBox.Information)
        msgbox.setWindowIcon(self.iconMain)
        if self.iconMainpixmap!=None:            
            thepm=self.iconMainpixmap.scaled(160,160, QtCore.Qt.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation)#QtCore.Qt.FastTransformation)
            #thepm.scaledToWidth(90,QtCore.Qt.TransformationMode.SmoothTransformation)#  QtCore.Qt.TransformationMode.SmoothTransformation) #QtCore.Qt.AspectRatioMode.KeepAspectRatio)            
            msgbox.setIconPixmap(thepm)
        msgbox.setText(amsg)           
        msgbox.setTextFormat(QtCore.Qt.RichText)
        msgbox.exec_()


    def Open_CSV_File_d(self):
        self.Open_CSV_File(None)

    def Open_CSV_File(self,afn=None):
        if afn==None:
            fileName=aDialog.openFileNameDialog(6) #6 is csv
        else:
            fileName=afn
        if fileName !=None:
            path=self.extract_path(fileName)
            aDialog.set_default_dir(path)
            self.csv_file_name=self.extract_filename(fileName)
            self.csv_file_path=self.extract_path(fileName)
            self.csv_path_file_name=fileName
            if self.des_res_path=='':
                self.des_res_path=self.csv_file_path
            self.set_path_labels()
            self.Read_CSV_File(fileName)
            self.last_opened['last_opened_csv']=fileName
            self.set_last_opened_yml_file()
    
    def Read_CSV_File(self,filename):
        self.df = pd.read_csv(filename, comment='#')
        if len(self.df)>0:
            self.Data_avilable=True            
            log.info('Read data file "{}".\n'.format(self.csv_file_name))
    
    def extract_filename(self,filename,withextension=True):
        fn= os.path.basename(filename)  # returns just the name
        fnnoext, fext = os.path.splitext(fn)
        fnnoext=fnnoext.replace(fext,'')
        fn=fnnoext+fext        
        if withextension==True:
            return fn
        else:                
            return  fnnoext 

    def extract_path(self,filename):
        fn= os.path.basename(filename)  # returns just the name
        fpath = os.path.abspath(filename)
        fpath = fpath.replace(fn,'')
        return fpath
    
    def get_appPath(self):
        # determine if application is a script file or frozen exe
        if getattr(sys, 'frozen', False):
            application_path = os.path.dirname(sys.executable)
        elif __file__:
            application_path = os.path.dirname(__file__)
        return application_path
    
    def create_results_directory(self,despath=''):
        # create results directory
        if despath=='':
            apath=self.csv_file_path
        else:
            apath=despath
        if os.path.exists(apath)==False:
            apath=self.csv_file_path     
       
        try:
            nnn='results'
            dirName = os.path.join(apath,nnn, '')            
            for iii in range(1,9999):
                isfolder=os.path.exists(dirName)    
                if isfolder==False:
                    os.makedirs(dirName)
                    break
                else:
                    nnn='results_'+str(iii)
                    dirName = os.path.join(apath,nnn, '')                        
                    log.info('Created results Folder:'+ dirName)
        except Exception as e:
            log.error(e)
            log.error('Result folder was not created!')
        return dirName

    def get_fields_in_csv_data(self,df):
        field_list=[]
        try:
            #field_list=list(df.columns.values)[-1]
            field_list=list(df.columns.values) 
        except:
            pass
        return field_list
    
    def is_field_in_csv_data(self,df,field):
        field_list=self.get_fields_in_csv_data(df)
        if field in field_list:
            return True
        else:
            return False

    def write_GUI_Log(self,text):
        self.append_text_to_text_edit(text)

    def append_text_to_text_edit(self,text):
        self.textEdit.moveCursor(QtGui.QTextCursor.End)
        self.textEdit.insertPlainText( text+'\r\n' )                
        try:
            lightblue=QtGui.QColor(0, 0, 255, 64)
            lightgreen=QtGui.QColor(0, 255, 0, 64)
            self.highlight_(self,self.textEdit,'[WARNING]','yellow',self.line_numberlistnW)
            self.highlight_(self,self.textEdit,'[ERROR]','red',self.line_numberlistE)        
            self.highlight_(self,self.textEdit,'isvalid: False',lightblue,self.line_numberlistlW) 
            self.highlight_(self,self.textEdit,'not in permitted list:',lightblue,self.line_numberlistlW)  
            self.highlight_(self,self.textEdit,'++++++++++++',lightgreen,self.line_numberlistlP)  
            _=self.get_linenumberlist_for_text(self.textEdit,text,[])# will select last line           
            self.statusbar.setStatusTip('{} Warnings, {} Errors'.format(len(self.line_numberlistW),len(self.line_numberlistE)))
        except Exception as e:
            #since log created before setup
            #print('Here error is ',e)
            self.line_numberlistlW=[]
            self.line_numberlistnW=[]
            self.line_numberlistE=[]
            self.line_numberlistlP=[]
            pass        
        self.send_log_to_all_dialogs(text)
    
    def set_highlights_(self,parent,obj,color,line_numberlist,justclear=False):        
        if isinstance(obj,QtWidgets.QTextEdit):            
            fmt=QtGui.QTextCharFormat()        
            fmt.setBackground(QtGui.QColor(color))
            try:
                highlight=parent.highligter
            except:
                highlight=SyntaxHighLighter(obj.document())
                parent.highligter=highlight

            if justclear==True:
                highlight.clearhighlight()                
                #print('Cleared Highligths, returning--->',line_numberlist)   
            else:
                try:
                    if len(line_numberlist)>0:
                        #print('Making Highligths, for--->',line_numberlist,obj)
                        for linenumber in line_numberlist:
                            highlight.highlightline(linenumber,fmt)
                except Exception as e:
                    print('Highlighting Error: {}'.format(e))        
        return line_numberlist
    
    def get_linenumberlist_for_text(self,obj,text,line_numberlist):        
        #print('----------got list:',line_numberlist,text,obj)
        if self.is_list(line_numberlist)==True and isinstance(obj,QtWidgets.QTextEdit):                
            bntot=obj.document().blockCount()
            bnlast=-1
            bn=0
            count=0            
            position=0   
            iii=0                               
            while iii <= bntot:
                if iii==0:
                    cursor=None                
                index,cursor=self.set_cursor_toselectText(obj,text,cursor)   
                bn=cursor.blockNumber()                        
                if index==-1:     
                    iii=bntot+1
                if bn>0 and bn not in line_numberlist:
                    line_numberlist.append(bn)  
                    bnlast=bn 
                if bn>0:            
                    iii=iii+bn  
                else:
                    iii=iii+1            
        return line_numberlist    

    def set_cursor_toselectText(self,texteditobj,text,cursor=None):
        if cursor==None:
            cursor = texteditobj.document().find(text)
        findIndex = cursor.anchor()        
        content = texteditobj.toPlainText()
        length = len(text)        
        index = content.find(text, findIndex)
        if index!=-1:            
            start = index
            cursor = texteditobj.textCursor()
            cursor.clearSelection()
            cursor.movePosition(QtGui.QTextCursor.Start, QtGui.QTextCursor.MoveAnchor)
            cursor.movePosition(QtGui.QTextCursor.Right, QtGui.QTextCursor.MoveAnchor, start + length)
            cursor.movePosition(QtGui.QTextCursor.Left, QtGui.QTextCursor.KeepAnchor, length)
            cursor.selectedText()
            texteditobj.setTextCursor(cursor)
        return index,cursor

    def send_log_to_all_dialogs(self,text):        
        try:                
            for id_d in self.open_Dialogs:
                dialog=self.open_Dialogs[id_d]
                dialog.DPPui.textEdit_Log.moveCursor(QtGui.QTextCursor.End)
                dialog.DPPui.textEdit_Log.insertPlainText( text+'\r\n' )
                try:
                    lightblue=QtGui.QColor(0, 0, 255, 64)
                    lightgreen=QtGui.QColor(0, 255, 0, 64)
                    self.highlight_(dialog,dialog.DPPui.textEdit_Log,'[WARNING]','yellow',dialog.line_numberlistW)
                    self.highlight_(dialog,dialog.DPPui.textEdit_Log,'[ERROR]','red',dialog.line_numberlistE)        
                    self.highlight_(dialog,dialog.DPPui.textEdit_Log,'isvalid: False',lightblue,dialog.line_numberlistlW)        
                    self.highlight_(dialog,dialog.DPPui.textEdit_Log,'not in permitted list:',lightblue,dialog.line_numberlistlW)                            
                    self.highlight_(dialog,dialog.DPPui.textEdit_Log,'++++++++++++',lightgreen,dialog.line_numberlistlP)                                                
                    _=self.get_linenumberlist_for_text(dialog.DPPui.textEdit_Log,text,[])# will select last line
                except Exception as e:
                    #print('Here error is ',e)
                    dialog.line_numberlistW=[]
                    dialog.line_numberlistE=[]
                    dialog.line_numberlistlW=[]
                    dialog.line_numberlistlP=[]
                    pass                
        except Exception as e:                
            #print('Sending logs to dialogs!'.format(e))     
            pass  
    def highlight_(self,parentobj,obj,hltext,color,hllist):        
        try:
            try:                    
                hllist=self.get_linenumberlist_for_text(obj,hltext,hllist)            
            except Exception as e:
                print('clear error:',e)
                hllist=self.set_highlights_(parentobj,obj,color,[],True)
            hllist=self.set_highlights_(parentobj,obj,color,hllist,False)  

        except Exception as e:                
            print('Setting heighlighs {}'.format(e))     
            pass          
    
    def close_dialogs(self):
        #Close dialogs
        for id_d in self.open_Dialogs:
            try:                
                dialog=self.open_Dialogs[id_d]
                dialog.quit()                               
            except Exception as e:
                #log.error(e)     
                pass  
        self.open_Dialogs={}
    
    def unlist_a_dialog(self,id_close):
        #Close dialogs
        diaglist=self.open_Dialogs
        for id_d in diaglist:
            if id_d==id_close:
                try:                                
                    self.open_Dialogs.pop(id_d)
                    break                             
                except Exception as e:
                    log.error('Unlisting Dialog {} : {}'.format(id_close,e))     
                    pass  

    def close_a_dialog(self,id_close):
        #Close dialogs
        diaglist=self.open_Dialogs
        for id_d in diaglist:
            if id_d==id_close:
                try:                
                    dialog=self.open_Dialogs[id_d]
                    dialog.quit()  
                    #self.open_Dialogs.pop(id_d) ->in quit
                    break                             
                except Exception as e:
                    log.error('Closing Dialog {} : {}'.format(id_close,e))     
                    pass  
        
class SyntaxHighLighter(QtGui.QSyntaxHighlighter):               
    def __init__(self,parent):
        super().__init__(parent)
        self.highlightlines={}
    def highlightline(self,line_number,fmt):
        if isinstance(line_number,int) and isinstance(fmt,QtGui.QTextCharFormat):
            if line_number>0:
                self.highlightlines[line_number]=fmt
                block=self.document().findBlockByLineNumber(line_number)
                self.rehighlightBlock(block)
    def clearhighlight(self):
        self.highlightlines={}
        self.rehighlight()
    
    #def highlightBlock(self, text: str) -> None:
    #    return super().highlightBlock(text)
    def highlightBlock(self, text):
        blocknumber=self.currentBlock().blockNumber()
        fmt=self.highlightlines.get(blocknumber)
        if fmt is not None:
            self.setFormat(0,len(text),fmt)



    
    
class MyWindow(QtWidgets.QMainWindow):           
    '''
    #This works
    def mousePressEvent(self, QMouseEvent):
        if QMouseEvent.button() == QtCore.Qt.LeftButton:
            print("Left Button Clicked")
        elif QMouseEvent.button() == QtCore.Qt.RightButton:
            #do what you want here
            print("Right Button Clicked")
    '''    
    def closeEvent(self,event):
        '''
        # ask to leave?
        result = QtWidgets.QMessageBox.question(self,
                      "Confirm Exit...",
                      "Are you sure you want to exit ?",
                      QtWidgets.QMessageBox.Yes| QtWidgets.QMessageBox.No)
        event.ignore()

        if result == QtWidgets.QMessageBox.Yes:
            #print('inside class')       
            # self.CCDialog      
        
            try:                
                ui.CCDialog.quit()                   
            except Exception as e:
                #log.error(e)     
                pass      
             
            ui.killer_event.set()            
            event.accept()
        '''
        # kill threads
        ui.killer_event.set()
        #Close dialogs
        oddict=ui.open_Dialogs.copy()
        for id_d in oddict:
            try:                
                dialog=ui.open_Dialogs[id_d]
                dialog.quit()
                #ui.PPDialog.quit()                   
            except Exception as e:
                #log.error(e)     
                pass  
        
        event.accept() 



class Receiver_Thread(threading.Thread):
    def __init__(self,killer_event,a_queue):
        threading.Thread.__init__(self,name="Stdout Receiver Thread")        
        self.killer_event=killer_event
        self.cycle_time=0.1
        self.a_queue=a_queue
        self.Receiver=MyReceiver(self.a_queue) 

    def run(self):    
        log.info('Logging Thread initialized')                       
        while not self.killer_event.wait(self.cycle_time):   
            self.Receiver.do_emits()
        log.info('Logging Thread Exit')  
    
    def quit(self):
        log.info('Thread quit received')                                   
        self.killer_event.set() 

# A QObject (to be run in a QThread) which sits waiting for data to come through a Queue.Queue().
# It blocks until data is available, and one it has got something from the queue, it sends
# it to the "MainThread" by emitting a Qt Signal 

class MyReceiver(QtCore.QObject):
    mysignal = QtCore.pyqtSignal(str)

    def __init__(self,a_queue,*args,**kwargs):
        QtCore.QObject.__init__(self,*args,**kwargs)
        self.a_queue = a_queue

    @QtCore.pyqtSlot()
    def do_emits(self):     
        if self.a_queue.not_empty==True:
            text = self.a_queue.get()
            self.mysignal.emit(text)            

if __name__ == "__main__":    
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = MyWindow() #QtWidgets.QMainWindow() #Modified to close windows
    ui = Ui_MainWindow_PP() #GUI_PostProcessing.Ui_MainWindow()
    aDialog=class_File_Dialogs.Dialogs()
    # Create Queue and redirect sys.stdout to this queue
    a_queue = queue.Queue()
    #sys.stdout = WriteStream(a_queue)
    # Log handler
    handler = class_LogHandler.ConsolePanelHandler(ui)          
    handler.setLevel(logging.INFO)
    handler.setFormatter(formatter)           
    log.addHandler(handler)

    ui.setupUi(MainWindow)
    ui.setupUi2(MainWindow)
    
    
    MainWindow.show()    
    sys.exit(app.exec_())